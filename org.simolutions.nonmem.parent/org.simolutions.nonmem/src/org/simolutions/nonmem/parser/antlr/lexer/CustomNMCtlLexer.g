/*
 * generated by Xtext 2.12.0
 */
lexer grammar CustomNMCtlLexer;
options {
	tokenVocab=InternalNMCtlLexer;
}
@header {
package org.simolutions.nonmem.parser.antlr.lexer;

// Hack: Use our own Lexer superclass by means of import. 
// Currently there is no other way to specify the superclass for the lexer.
import org.eclipse.xtext.parser.antlr.Lexer;
}
@members {
boolean readRecordOptions = false;
boolean nextTokenIsFilename = false;
}

RULE_PROBLEM_RECORD : '$PRO' ('B'|'BL'|'BLE'|'BLEM')? RULE_WS ~(('\n'|'\r'))* ('\r'? '\n')?;

RULE_NM_COMMENT : ';' ~(('\n'|'\r'))* ('\r'? '\n')?;

RULE_INPUT_RECORD : '$INPUT';

RULE_DATA_RECORD : '$DATA' {nextTokenIsFilename=true; readRecordOptions = true;};

RULE_SUBROUTINES_RECORD : '$SUBROUTINES';

RULE_PRIOR_RECORD : '$PRIOR';

RULE_PK_RECORD : '$PK';

RULE_ERROR_RECORD : '$ERROR';

RULE_THETA_RECORD : '$THETA';

RULE_OMEGA_RECORD : '$OMEGA';

RULE_SIGMA_RECORD : '$SIGMA';

RULE_ESTIMATION_RECORD : '$EST' ('IMATION'|'IMATIO'|'IMATI'|'IMAT'|'IMA'|'IM'|'I')? {readRecordOptions = true;};

RULE_COVARIANCE_RECORD : '$COV' ('ARIANCE'|'ARIANC'|'ARIAN'|'ARIA'|'ARI'|'AR'|'A')?;

RULE_TABLE_RECORD : '$TABLE';

RULE_WS : (' '|'\t'|'\r'|'\n')+;

RULE_COMMA : ',';

RULE_PARENL : '(';

RULE_PARENR : ')';

RULE_FIX :{!nextTokenIsFilename}? 'FIXED'|'FIX';

RULE_BLOCK :{!nextTokenIsFilename}? 'BLOCK';

RULE_VALUES :{!nextTokenIsFilename}? 'VALUES';

RULE_SAME :{!nextTokenIsFilename}? 'SAME';

RULE_DIAGONAL :{!nextTokenIsFilename}? 'DIAGONAL';

RULE_EQ : '=';

RULE_PLUS : '+';

RULE_MINUS : '-';

RULE_MULT : '*';

RULE_DIV : '/';

RULE_POW : '^';

RULE_X :{!nextTokenIsFilename}? 'x';

RULE_THETA :{!nextTokenIsFilename}? 'THETA';

RULE_OMEGA :{!nextTokenIsFilename}? 'OMEGA';

RULE_SIGMA :{!nextTokenIsFilename}? 'SIGMA';

RULE_ETA :{!nextTokenIsFilename}? 'ETA';

RULE_EPS :{!nextTokenIsFilename}? 'EPS';

RULE_ERR :{!nextTokenIsFilename}? 'ERR';

RULE_AND_OP :{!nextTokenIsFilename}? '.AND.';

RULE_OR_OP : {!nextTokenIsFilename}? '.OR.';

RULE_EQ_OP : {!nextTokenIsFilename}?('.EQ.'|'==');

RULE_NE_OP : {!nextTokenIsFilename}?('.NE.'|'/=');

RULE_LE_OP : {!nextTokenIsFilename}?('.LE.'|'<=');

RULE_GE_OP : {!nextTokenIsFilename}?('.GE.'|'>=');

RULE_LT_OP : {!nextTokenIsFilename}?('.LT.'|'>');

RULE_GT_OP :{!nextTokenIsFilename}? ('.GT.'|'<');

RULE_OPTION_KEY : {!nextTokenIsFilename && readRecordOptions}?=>(
	'POSTHOC' |
	'NOPOSTHOC' |
	'INTERACTION' |
	'NOABORT'|
	'UNCONDITIONAL' |
	'NOPRINT' |
	'NOAPPEND' |
	'FIRSTONLY' |
	'ONEHEADER'
	// etc: continue for all of the known nonmem options without values
);

RULE_OPTION_KEY_ID : {!nextTokenIsFilename && readRecordOptions}?=>(
	'METHOD' |
	'IGNORE' |
	'MATRIX'
	// Oh great! PRINT is something with a number value in an $ESTIMATION record, but it can also be 'PRINT=E' in the $COV record!  
);

RULE_OPTION_KEY_FILENAME
	:	{!nextTokenIsFilename && readRecordOptions}?=>(
	'FILE' | 'FILENAME'
	) {nextTokenIsFilename=true;};

RULE_OPTION_KEY_INT : {!nextTokenIsFilename && readRecordOptions}?=>(
	'NITER' |
	'PRINT' |
	'SIGL' |
	'CTYPE' |
	'CITER' |
	'NOPRIOR' |
	'NSIG' |
	'NBURN' |
	'SEED' |
	'ISAMPLE' |
	'MAPITER' |
	'EONLY' |
	'MAXEVAL'
);

RULE_OPTION_KEY_FLOAT: {!nextTokenIsFilename && readRecordOptions}?=>(
	'CALPHA'
);

RULE_OPTION_KEY_INTLIST : {!nextTokenIsFilename}? 'CUSTOM4';

// This has to be first, because if next token is filename, we need to read it!
RULE_FILENAME
	:	{nextTokenIsFilename}? ('a'..'z'|'A'..'Z'|'_'|'0'..'9'|'-'|'.')+ {nextTokenIsFilename=false;};

fragment INT : ('0'..'9')+;
RULE_FLOAT :
(('+'|'-')? INT ('.'INT?) (('E'|'e')('+'|'-')? INT )?) |
(('+'|'-')? INT           (('E'|'e')('+'|'-')? INT ) ) |
(                ('.'INT) (('E'|'e')('+'|'-')? INT )?) |
('-'        INT                                      );

/*RULE_ID : {!readFullWordAsId}? (('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*)
	|
	(
	{readFullWordAsId}? ('a'..'z'|'A'..'Z'|'_'|'0'..'9'|'.'|'-')+ {readFullWordAsId=false;}
	);
	*/
RULE_DOT:	 '.';
RULE_ID : (('a'..'z'|'A'..'Z'|'_') ('a'..'z'|'A'..'Z'|'_'|'0'..'9')*) ;
RULE_STRING : ('"' ('\\' .|~(('\\'|'"')))* '"'|'\'' ('\\' .|~(('\\'|'\'')))* '\'');
RULE_INT : INT;
